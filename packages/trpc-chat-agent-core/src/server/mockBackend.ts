import { BaseMessage } from '@langchain/core/messages';
import {
  AdvancedAIMessageData,
  AnyStructuredChatTool,
  ChatAgent,
  ClientSideConversationUpdate,
  HumanMessageData,
  ServerSideChatConversation,
} from '../common';
import { AgentsBackend } from './builder';

export class MockAgentBackend extends AgentsBackend<[], any> {
  constructor() {
    super();
  }

  public createAgent = <Tools extends readonly AnyStructuredChatTool[]>(
    agentArgs: CreateMockAgentArgs<Tools>
  ): ChatAgent<Tools> => {
    return {
      async *invoke(chatArgs) {
        const conversationId = chatArgs.conversationData.id ?? 'dummy_conversation';

        const { conversationData, chatPath } = chatArgs;
        const conversation = new ServerSideChatConversation(conversationData);
        const messages = conversation.asMessagesArray(chatPath);

        const aiMessageId = conversation.getAIMessageIdAt(chatPath);
        if (!aiMessageId) {
          throw new Error('No AI message for ID generated by this point, this is unexpected');
        }

        const response = agentArgs.generateResponseUpdates({
          messages,
          conversationId,
          messageId: aiMessageId,
        });
        for (const { update, delay } of response) {
          await new Promise((resolve) => setTimeout(resolve, delay));
          yield {
            side: 'client',
            update: { ...update, conversationId } as ClientSideConversationUpdate,
          };
        }
      },
    };
  };
}

export type ResponseUpdate = {
  update: Omit<ClientSideConversationUpdate, 'conversationId'>;
  delay: number;
};

export type CreateMockAgentArgs<Tools extends readonly AnyStructuredChatTool[]> = {
  tools: Tools;
  generateResponseUpdates: (args: {
    messages: (HumanMessageData | AdvancedAIMessageData<Tools>)[];
    messageId?: string;
    conversationId?: string;
  }) => ResponseUpdate[];
};
