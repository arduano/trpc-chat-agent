import type { GetToolByName } from '../clientState';
import type {
  AdvancedAIMessageData,
  AgentUpdateMessage,
  AnyStructuredChatTool,
  ChatAgent,
  ClientSideConversationUpdate,
  HumanMessageData,
  ServerSideConversationUpdate,
  ToolCallbackInvoker,
  ToolCallOutput,
} from '../common';
import { ServerSideChatConversation } from '../common';
import { AgentsBackend } from './builder';

export class MockAgentBackend extends AgentsBackend<[], any> {
  constructor() {
    super();
  }

  public createAgent = <const Tools extends readonly AnyStructuredChatTool[]>(
    agentArgs: CreateMockAgentArgs<Tools>
  ): ChatAgent<Tools> => {
    return {
      async *invoke(chatArgs) {
        const conversationId = chatArgs.conversationData.id ?? 'dummy_conversation';

        const { conversationData, chatPath } = chatArgs;
        const conversation = new ServerSideChatConversation(conversationData);
        const messages = conversation.asMessagesArray(chatPath);

        const aiMessageId = conversation.getAIMessageIdAt(chatPath);
        if (!aiMessageId) {
          throw new Error('No AI message for ID generated by this point, this is unexpected');
        }

        const lastHumanMessage = conversation.getHumanMessageAt(chatPath);
        if (!lastHumanMessage) {
          throw new Error('No human message for ID generated by this point, this is unexpected');
        }

        const eventHelper = new MockEventHelper(
          aiMessageId,
          conversationId,
          agentArgs.tools,
          conversation,
          chatArgs.callbackInvoker
        );
        const promise = agentArgs.generateResponseUpdates({
          messages,
          lastHumanMessage: lastHumanMessage.content as string,
          conversationId,
          messageId: aiMessageId,
          create: eventHelper,
        });
        promise.then(() => eventHelper.emitter.end());

        for await (const { server, client } of eventHelper) {
          if (client) {
            yield {
              side: 'client',
              update: client,
            } satisfies AgentUpdateMessage;
          }
          if (server) {
            yield {
              side: 'server',
              update: server,
            } satisfies AgentUpdateMessage;
          }
        }
      },
    };
  };
}

export type ResponseUpdate = {
  server?: ServerSideConversationUpdate;
  client?: ClientSideConversationUpdate;
};

export type CreateMockAgentArgs<Tools extends readonly AnyStructuredChatTool[]> = {
  tools: Tools;
  generateResponseUpdates: (args: {
    messages: (HumanMessageData | AdvancedAIMessageData<Tools>)[];
    lastHumanMessage: string;
    messageId?: string;
    conversationId?: string;
    create: MockEventHelper<Tools>;
  }) => Promise<void>;
};

type DeepPartial<TObject> = TObject extends object
  ? {
      [P in keyof TObject]?: DeepPartial<TObject[P]>;
    }
  : TObject;

export type MockToolCallSchema<
  Tools extends readonly AnyStructuredChatTool[],
  Name extends Tools[number]['TypeInfo']['Name'],
> = {
  toolName: Name;
  inProgressArgs?: DeepPartial<GetToolByName<Name, Tools>['TypeInfo']['Args']>[];
  argsProgressDelay?: number;
  finalArgs: GetToolByName<Name, Tools>['TypeInfo']['Args'];
};

export class MockEventHelper<Tools extends readonly AnyStructuredChatTool[]> {
  constructor(
    readonly messageId: string,
    readonly conversationId: string,
    readonly tools: Tools,
    readonly conversation: ServerSideChatConversation<ChatAgent<AnyStructuredChatTool[]>>,
    readonly callbackInvoker: ToolCallbackInvoker
  ) {}

  emitter: EventStreamer<ResponseUpdate> = new EventStreamer();

  async beginMessagePart(delay: number) {
    await this.emitter.emit(
      {
        server: {
          kind: 'begin-new-ai-message-part',
          messageId: this.messageId,
          conversationId: this.conversationId,
        },
        client: {
          kind: 'begin-new-ai-message-part',
          messageId: this.messageId,
          conversationId: this.conversationId,
        },
      },
      delay
    );
  }

  async aiMessagePartContent(text: string, tokenDelay: number) {
    const tokens = mockTokenize(text);
    let cumulative: string = '';
    const updates = tokens.map<ResponseUpdate>((c) => {
      cumulative += c;
      return {
        server: {
          kind: 'update-content',
          messageId: this.messageId,
          totalContent: cumulative,
          conversationId: this.conversationId,
        },
        client: {
          kind: 'update-content',
          messageId: this.messageId,
          contentToAppend: c,
          conversationId: this.conversationId,
        },
      };
    });

    await this.emitter.emitMany(updates, tokenDelay);
  }

  async *[Symbol.asyncIterator]() {
    for await (const update of this.emitter) {
      yield update;
    }
  }

  mockTokensList(text: string) {
    return mockTokenize(text);
  }

  mockCumulativeTokensList(text: string) {
    const tokens = mockTokenize(text);
    let cumulative: string = '';
    return tokens.map((c) => {
      cumulative += c;
      return cumulative;
    });
  }

  toolCallSchema<const Name extends Tools[number]['TypeInfo']['Name']>(schema: MockToolCallSchema<Tools, Name>) {
    return schema;
  }

  async aiToolCalls<const Calls extends readonly MockToolCallSchema<Tools, string>[]>(...calls: Calls) {
    const chosenTools: Tools[number][] = [];
    const chosenToolCallIds: string[] = [];

    let callIdCounter = 0;
    const getCallId = () => {
      callIdCounter++;
      return `${this.messageId}-tool-call-${callIdCounter}`;
    };

    for (const call of calls) {
      const tool = this.tools.find((t) => t.name === call.toolName);
      if (!tool) {
        throw new Error(`Tool ${call.toolName} not found`);
      }
      chosenTools.push(tool);

      const callId = getCallId();
      chosenToolCallIds.push(callId);

      await this.emitter.emit(
        {
          client: {
            kind: 'begin-tool-call',
            messageId: this.messageId,
            toolCallId: callId,
            toolCallName: tool.name,
            conversationId: this.conversationId,
          },
        },
        0
      );

      if (call.inProgressArgs) {
        const delay = call.argsProgressDelay ?? 0;

        for (const args of call.inProgressArgs) {
          const clientArgsMapped = await tool.mapArgsForClient?.(args);

          await this.emitter.emit(
            {
              client: {
                kind: 'update-tool-call',
                messageId: this.messageId,
                toolCallId: callId,
                newArgs: clientArgsMapped,
                conversationId: this.conversationId,
              },
            },
            delay
          );
        }
      }

      const finalClientArgs = tool.mapArgsForClient?.(call.finalArgs);
      await this.emitter.emit(
        {
          server: {
            kind: 'begin-tool-call',
            messageId: this.messageId,
            toolCallId: callId,
            toolCallName: tool.name,
            newArgs: call.finalArgs,
            newClientArgs: finalClientArgs,
          },
          client: {
            kind: 'update-tool-call',
            messageId: this.messageId,
            toolCallId: callId,
            newArgs: finalClientArgs,
            conversationId: this.conversationId,
          },
        },
        0
      );
    }

    // Zip calls, chosenTools and chosenToolCallIds into a single array of tuples
    const allCalls = calls.map(
      (call, i) =>
        ({
          call,
          tool: chosenTools[i],
          callId: chosenToolCallIds[i],
        }) as const
    );

    const allResponses = await Promise.all(
      allCalls.map(async ({ call, callId, tool }) => {
        const response = await tool.invoke({
          ctx: null as any,
          conversation: this.conversation,
          input: call.finalArgs,
          toolCallId: callId,
          callbackInvoker: this.callbackInvoker,
          progressCallback: async (data) => {
            await this.emitter.emit(
              {
                client: {
                  kind: 'update-tool-call',
                  messageId: this.messageId,
                  toolCallId: callId,
                  conversationId: this.conversationId,
                  newProgressStatus: data,
                },
              },
              0
            );
          },
        });

        await this.emitter.emit(
          {
            server: {
              kind: 'update-tool-call',
              messageId: this.messageId,
              toolCallId: callId,
              newResult: response.response,
              newClientResult: response.clientResult,
              newState: 'complete',
            },
            client: {
              kind: 'update-tool-call',
              messageId: this.messageId,
              toolCallId: callId,
              newResult: response.clientResult,
              conversationId: this.conversationId,
              newState: 'complete',
            },
          },
          0
        );

        return response;
      })
    );

    type GetToolResult<Tool extends AnyStructuredChatTool> = Tool['TypeInfo']['ResultForClient'];

    type TransformCalls<
      Tools extends readonly AnyStructuredChatTool[],
      Calls extends readonly MockToolCallSchema<Tools, Tools[number]['TypeInfo']['Name']>[],
    > = {
      [Index in keyof Calls]: ToolCallOutput<string, GetToolResult<GetToolByName<Calls[Index]['toolName'], Tools>>>;
    };

    return allResponses as TransformCalls<Tools, Calls>;
  }
}

function mockTokenize(text: string) {
  const splitBySpace = text.split(' ').map((s) => s + ' ');

  const tokens: string[] = [];

  for (const word of splitBySpace) {
    if (word.length <= 10) {
      tokens.push(word);
      continue;
    }

    // For longer words, split them into chunks of up to 10 characters
    let remainingWord = word;
    while (remainingWord.length > 0) {
      // Randomly choose a split point between 4 and 10 characters
      // or the remaining length, whichever is smaller
      const maxSplitPoint = Math.min(10, remainingWord.length);
      const minSplitPoint = Math.min(4, maxSplitPoint);
      const splitPoint = Math.floor(Math.random() * (maxSplitPoint - minSplitPoint + 1)) + minSplitPoint;

      tokens.push(remainingWord.slice(0, splitPoint));
      remainingWord = remainingWord.slice(splitPoint);
    }
  }

  return tokens;
}

type QueuedEvent<T> = {
  data: T;
  delay: number;
};

export class EventStreamer<T> {
  private eventQueue: QueuedEvent<T>[] = [];
  private pendingResolves: Array<() => void> = [];
  private newEventsPromise?: Promise<void>;
  private newEventsResolve?: () => void;
  private isEnded = false;

  /**
   * Add multiple events to the stream. Returns a promise that resolves
   * once the queue becomes empty again. (That is, after *all* events—
   * including those previously queued—have been yielded.)
   */
  emitMany(data: T[], delay: number): Promise<void> {
    // Push new items
    this.eventQueue.push(...data.map((d) => ({ data: d, delay })));

    // If the iterator is currently waiting for new events, wake it up.
    if (this.newEventsResolve) {
      this.newEventsResolve();
      this.newEventsResolve = undefined;
      this.newEventsPromise = undefined;
    }

    // Create a new "drain" promise for these newly pushed events
    let resolver: () => void;
    const p = new Promise<void>((resolve) => {
      resolver = resolve;
    });

    // Keep track so that once the queue is empty, we can resolve everyone
    this.pendingResolves.push(resolver!);

    return p;
  }

  /**
   * Emit a single event. This is a convenience wrapper for `emitMany`.
   */
  emit(data: T, delay: number): Promise<void> {
    return this.emitMany([data], delay);
  }

  /**
   * Terminate the stream, discarding any queued events that have
   * not yet been yielded. Also resolves all outstanding promises.
   */
  end() {
    this.isEnded = true;
    // Discard all events
    this.eventQueue = [];

    // Resolve all pending "drain" promises
    for (const resolve of this.pendingResolves) {
      resolve();
    }
    this.pendingResolves = [];

    // Also wake up the iterator if it's waiting for new events
    if (this.newEventsResolve) {
      this.newEventsResolve();
      this.newEventsResolve = undefined;
      this.newEventsPromise = undefined;
    }
  }

  /**
   * Async iterator interface. Yields events with their specified delay.
   */
  async *[Symbol.asyncIterator](): AsyncGenerator<T, void, unknown> {
    while (!this.isEnded) {
      // If empty, resolve all "drain" promises and then wait for new events.
      if (this.eventQueue.length === 0) {
        // The queue is empty, so resolve all pending drain promises
        for (const resolve of this.pendingResolves) {
          resolve();
        }
        this.pendingResolves = [];

        // If not ended, wait for new events
        if (!this.isEnded) {
          if (!this.newEventsPromise) {
            this.newEventsPromise = new Promise((resolve) => {
              this.newEventsResolve = resolve;
            });
          }
          await this.newEventsPromise;
        }
        continue;
      }

      // Dequeue one event
      const { data, delay } = this.eventQueue.shift()!;

      // Delay before yielding (if desired)
      if (delay > 0) {
        await new Promise((resolve) => setTimeout(resolve, delay));
      }

      // Yield the event
      yield data;
    }

    // Once ended, we do a final pass to resolve pending promises
    for (const resolve of this.pendingResolves) {
      resolve();
    }
    this.pendingResolves = [];
  }
}
